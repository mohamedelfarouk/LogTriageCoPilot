1.NullPointerException (e.g., user.getEmail() is null) → Missing validation, nullable DB column, DTO mapping bug, unexpected null from upstream → Checks: inspect the first “app frame” in stack trace, confirm the field is nullable in DB/entity, check controller/service input validation → Fix: validate inputs (fail fast), add null-safe handling, enforce DB constraints where appropriate, add test covering null case.
2.HTTP 500 after a request (Spring MVC / DispatcherServlet mentions) → Unhandled exception bubbled to the web layer → Checks: locate the “Request received” line + matching RequestId, find first ERROR in that request group, confirm global exception handler output → Fix: handle expected exceptions, return correct 4xx for bad input, add structured error response + logging.
3.QueryTimeoutException / SQLTimeoutException (“query has timed out”) → Slow query, lock contention, overloaded DB, query timeout configured too low → Checks: identify query/runtime, check DB load, inspect indexes/explain plan, look for locks, compare timeout setting to typical query duration → Fix: optimize query/indexing, reduce returned data, tune timeout knowingly, add caching for heavy reads. (Time-outs often happen when a query runs longer than the configured timeout.)
4.ORA-01013: user requested cancel of current operation → Client/app cancelled the DB call (often due to a timeout), less commonly DBA/job cancels SQL → Checks: confirm app-side timeouts (JDBC/query timeout, proxy/gateway timeouts), look for “exceeded threshold” warning before the error, correlate with request duration → Fix: tune query + indexes first, then align timeout settings across layers so they make sense together.
5.Degraded response but still 200 OK (Degraded) served from cache fallback → Primary data path failed (DB timeout) but fallback returned stale/cached data → Checks: confirm fallback log lines (“attempting stale cache”, cache hit), confirm primary failure (timeout/rollback), check freshness/TTL of cache key → Fix: alert on degraded mode, make degraded visible to clients, fix root cause (DB query/load), review fallback policy + cache TTL.
6.RedisConnectionException / “Unable to connect … connection refused” → Redis service down, wrong host/port, network/security group/firewall, DNS mismatch → Checks: verify host resolves and is reachable, verify Redis is up, test connectivity using a redis client, confirm correct endpoint/port and credentials (if used) → Fix: start/restore Redis, fix config/DNS, open network paths, add retries/backoff and circuit breaker.
7.Cache miss → fallback to DB → Often normal (cold cache) but can amplify DB load during incidents → Checks: is miss rate spiking? is DB already slow? are keys too granular? → Fix: tune caching strategy (TTL, key design), pre-warm critical keys, add request coalescing to avoid thundering herd.
8.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out … → Pool exhausted (all connections in use), connection leak, DB too slow so connections are held, DB unreachable so connections can’t be acquired in time → Checks: compare concurrent requests vs pool size, check for slow queries, enable leak detection, check DB connectivity; verify connection-timeout meaning (max time to wait for a pool connection) → Fix: fix slow queries/leaks, right-size pool, reduce concurrency, align timeouts; don’t “just increase timeout” unless you know why.
9.“Transaction rolled back” after infra errors → DB connectivity lost mid-transaction, timeouts, deadlocks/lock timeouts → Checks: find the first failure (DB timeout/pool timeout), correlate with rollback log line, check retry logic behavior → Fix: make operations idempotent where possible, retry safely at the right layer, reduce transaction scope, improve DB stability/perf.
Suspicious text in logs like “Ignore previous instructions / system prompt …” → Prompt injection attempt inside untrusted log content → Checks: detect and flag these lines; verify your system never treats log text as instructions → Fix: label logs as DATA only, strip/quote suspicious lines for the model, keep “securityFlags” for audit. (Prompt injection is explicitly called out as a top LLM risk.)
